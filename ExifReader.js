// Generated by CoffeeScript 1.6.2
/*
# ExifReader 1.0.1
# http://github.com/mattiasw/exifreader
# Copyright (C) 2011-2013  Mattias Wallander <mattias@wallander.eu>
# Licensed under the GNU Lesser General Public License version 3 or later
# See license text at http://www.gnu.org/licenses/lgpl.txt
*/


(function() {
  (typeof exports !== "undefined" && exports !== null ? exports : this).ExifReader = (function() {
    var _this = this;

    ExifReader.prototype._MIN_DATA_BUFFER_LENGTH = 2;

    ExifReader.prototype._JPEG_ID_SIZE = 2;

    ExifReader.prototype._JPEG_ID = 0xffd8;

    ExifReader.prototype._APP_MARKER_SIZE = 2;

    ExifReader.prototype._APP0_MARKER = 0xffe0;

    ExifReader.prototype._APP1_MARKER = 0xffe1;

    ExifReader.prototype._APP13_MARKER = 0xffed;

    ExifReader.prototype._APP15_MARKER = 0xffef;

    ExifReader.prototype._APP_ID_OFFSET = 4;

    ExifReader.prototype._BYTES_Exif = 0x45786966;

    ExifReader.prototype._BYTES_8BIM = 0x3842494d;

    ExifReader.prototype._TIFF_HEADER_OFFSET = 10;

    ExifReader.prototype._IPTC_DATA_OFFSET = 18;

    ExifReader.prototype._BYTE_ORDER_BIG_ENDIAN = 0x4949;

    ExifReader.prototype._BYTE_ORDER_LITTLE_ENDIAN = 0x4d4d;

    function ExifReader() {
      var _this = this;

      this._getTagValueAt = {
        1: function(offset) {
          return _this._getByteAt(offset);
        },
        2: function(offset) {
          return _this._getAsciiAt(offset);
        },
        3: function(offset) {
          return _this._getShortAt(offset);
        },
        4: function(offset) {
          return _this._getLongAt(offset);
        },
        5: function(offset) {
          return _this._getRationalAt(offset);
        },
        7: function(offset) {
          return _this._getUndefinedAt(offset);
        },
        9: function(offset) {
          return _this._getSlongAt(offset);
        },
        10: function(offset) {
          return _this._getSrationalAt(offset);
        }
      };
      this._tiffHeaderOffset = 0;
      this._iptcDataOffset = 0;
    }

    /*
    # Loads all the Exif tags from the specified image file buffer.
    #
    # data ArrayBuffer Image file data
    */


    ExifReader.prototype.load = function(data) {
      return this.loadView(new DataView(data));
    };

    /*
    # Loads all the Exif tags from the specified image file buffer view. Probably
    # used when DataView isn't supported by the browser.
    #
    # @_dataView DataView Image file data view
    */


    ExifReader.prototype.loadView = function(_dataView) {
      var foundMetaData;

      this._dataView = _dataView;
      foundMetaData = false;
      this._tags = {};
      this._checkImageHeader();
      if (this._hasExifData()) {
        foundMetaData = true;
        this._readTags();
      }
      if (this._hasIptcData()) {
        foundMetaData = true;
        this._readIptcTags();
      }
      if (!foundMetaData) {
        throw new Error('No Exif data');
      }
    };

    ExifReader.prototype._checkImageHeader = function() {
      var dataView;

      dataView = this._dataView;
      if (dataView.byteLength < this._MIN_DATA_BUFFER_LENGTH || dataView.getUint16(0, false) !== this._JPEG_ID) {
        throw new Error('Invalid image format');
      }
      return this._parseAppMarkers(dataView);
    };

    ExifReader.prototype._parseAppMarkers = function(dataView) {
      var appMarkerPosition, fieldLength, _results;

      appMarkerPosition = this._JPEG_ID_SIZE;
      _results = [];
      while (true) {
        if (appMarkerPosition + this._APP_ID_OFFSET + 5 > dataView.byteLength) {
          break;
        }
        if (this._isApp1ExifMarker(dataView, appMarkerPosition)) {
          fieldLength = dataView.getUint16(appMarkerPosition + this._APP_MARKER_SIZE, false);
          this._tiffHeaderOffset = appMarkerPosition + this._TIFF_HEADER_OFFSET;
        } else if (this._isApp13PhotoshopMarker(dataView, appMarkerPosition)) {
          fieldLength = dataView.getUint16(appMarkerPosition + this._APP_MARKER_SIZE, false);
          this._iptcDataOffset = appMarkerPosition + this._IPTC_DATA_OFFSET;
        } else if (this._isAppMarker(dataView, appMarkerPosition)) {
          fieldLength = dataView.getUint16(appMarkerPosition + this._APP_MARKER_SIZE, false);
        } else {
          break;
        }
        _results.push(appMarkerPosition += this._APP_MARKER_SIZE + fieldLength);
      }
      return _results;
    };

    ExifReader.prototype._isApp1ExifMarker = function(dataView, appMarkerPosition) {
      return dataView.getUint16(appMarkerPosition, false) === this._APP1_MARKER && dataView.getUint32(appMarkerPosition + this._APP_ID_OFFSET, false) === this._BYTES_Exif && dataView.getUint8(appMarkerPosition + this._APP_ID_OFFSET + 4, false) === 0x00;
    };

    ExifReader.prototype._isApp13PhotoshopMarker = function(dataView, appMarkerPosition) {
      return dataView.getUint16(appMarkerPosition, false) === this._APP13_MARKER && this._getString(dataView, appMarkerPosition + this._APP_ID_OFFSET, 13) === 'Photoshop 3.0' && dataView.getUint8(appMarkerPosition + this._APP_ID_OFFSET + 13, false) === 0x00;
    };

    ExifReader.prototype._getString = function(dataView, offset, length) {
      var chars, i;

      chars = (function() {
        var _i, _results;

        _results = [];
        for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
          _results.push(dataView.getUint8(offset + i, false));
        }
        return _results;
      })();
      return this._getAsciiValue(chars).join('');
    };

    ExifReader.prototype._isAppMarker = function(dataView, appMarkerPosition) {
      var appMarker;

      appMarker = dataView.getUint16(appMarkerPosition, false);
      return appMarker >= this._APP0_MARKER && appMarker <= this._APP15_MARKER;
    };

    ExifReader.prototype._hasExifData = function() {
      return this._tiffHeaderOffset !== 0;
    };

    ExifReader.prototype._hasIptcData = function() {
      return this._iptcDataOffset !== 0;
    };

    ExifReader.prototype._readTags = function() {
      this._setByteOrder();
      this._read0thIfd();
      this._readExifIfd();
      this._readGpsIfd();
      return this._readInteroperabilityIfd();
    };

    ExifReader.prototype._setByteOrder = function() {
      if (this._dataView.getUint16(this._tiffHeaderOffset) === this._BYTE_ORDER_BIG_ENDIAN) {
        return this._littleEndian = true;
      } else if (this._dataView.getUint16(this._tiffHeaderOffset) === this._BYTE_ORDER_LITTLE_ENDIAN) {
        return this._littleEndian = false;
      } else {
        throw new Error('Illegal byte order value. Faulty image.');
      }
    };

    ExifReader.prototype._read0thIfd = function() {
      var ifdOffset;

      ifdOffset = this._getIfdOffset();
      return this._readIfd('0th', ifdOffset);
    };

    ExifReader.prototype._getIfdOffset = function() {
      return this._tiffHeaderOffset + this._getLongAt(this._tiffHeaderOffset + 4);
    };

    ExifReader.prototype._readExifIfd = function() {
      var ifdOffset;

      if (this._tags['Exif IFD Pointer'] != null) {
        ifdOffset = this._tiffHeaderOffset + this._tags['Exif IFD Pointer'].value;
        return this._readIfd('exif', ifdOffset);
      }
    };

    ExifReader.prototype._readGpsIfd = function() {
      var ifdOffset;

      if (this._tags['GPS Info IFD Pointer'] != null) {
        ifdOffset = this._tiffHeaderOffset + this._tags['GPS Info IFD Pointer'].value;
        return this._readIfd('gps', ifdOffset);
      }
    };

    ExifReader.prototype._readInteroperabilityIfd = function() {
      var ifdOffset;

      if (this._tags['Interoperability IFD Pointer'] != null) {
        ifdOffset = this._tiffHeaderOffset + this._tags['Interoperability IFD Pointer'].value;
        return this._readIfd('interoperability', ifdOffset);
      }
    };

    ExifReader.prototype._readIfd = function(ifdType, offset) {
      var fieldIndex, numberOfFields, tag, _i, _results;

      numberOfFields = this._getShortAt(offset);
      offset += 2;
      _results = [];
      for (fieldIndex = _i = 0; 0 <= numberOfFields ? _i < numberOfFields : _i > numberOfFields; fieldIndex = 0 <= numberOfFields ? ++_i : --_i) {
        tag = this._readTag(ifdType, offset);
        this._tags[tag.name] = {
          'value': tag.value,
          'description': tag.description
        };
        _results.push(offset += 12);
      }
      return _results;
    };

    ExifReader.prototype._readTag = function(ifdType, offset) {
      var tagCode, tagCount, tagDescription, tagName, tagType, tagValue, tagValueOffset;

      tagCode = this._getShortAt(offset);
      tagType = this._getShortAt(offset + 2);
      tagCount = this._getLongAt(offset + 4);
      if (this._typeSizes[tagType] * tagCount <= 4) {
        tagValue = this._getTagValue(offset + 8, tagType, tagCount);
      } else {
        tagValueOffset = this._getLongAt(offset + 8);
        tagValue = this._getTagValue(this._tiffHeaderOffset + tagValueOffset, tagType, tagCount);
      }
      if (tagType === this._tagTypes['ASCII']) {
        tagValue = this._splitNullSeparatedAsciiString(tagValue);
      }
      if (this._tagNames[ifdType][tagCode] != null) {
        if ((this._tagNames[ifdType][tagCode]['name'] != null) && (this._tagNames[ifdType][tagCode]['description'] != null)) {
          tagName = this._tagNames[ifdType][tagCode]['name'];
          tagDescription = this._tagNames[ifdType][tagCode]['description'](tagValue);
        } else {
          tagName = this._tagNames[ifdType][tagCode];
          if (tagValue instanceof Array) {
            tagDescription = tagValue.join(', ');
          } else {
            tagDescription = tagValue;
          }
        }
        return {
          'name': tagName,
          'value': tagValue,
          'description': tagDescription
        };
      } else {
        return {
          'name': "undefined-" + tagCode,
          'value': tagValue,
          'description': tagValue
        };
      }
    };

    ExifReader.prototype._getTagValue = function(offset, type, count) {
      var tagValue, value, valueIndex;

      value = (function() {
        var _i, _results;

        _results = [];
        for (valueIndex = _i = 0; 0 <= count ? _i < count : _i > count; valueIndex = 0 <= count ? ++_i : --_i) {
          tagValue = this._getTagValueAt[type](offset);
          offset += this._typeSizes[type];
          _results.push(tagValue);
        }
        return _results;
      }).call(this);
      if (value.length === 1) {
        value = value[0];
      } else if (type === this._tagTypes['ASCII']) {
        value = this._getAsciiValue(value);
      }
      return value;
    };

    ExifReader.prototype._getAsciiValue = function(charArray) {
      var charCode, newCharArray;

      return newCharArray = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = charArray.length; _i < _len; _i++) {
          charCode = charArray[_i];
          _results.push(String.fromCharCode(charCode));
        }
        return _results;
      })();
    };

    ExifReader.prototype._getByteAt = function(offset) {
      return this._dataView.getUint8(offset);
    };

    ExifReader.prototype._getAsciiAt = function(offset) {
      return this._dataView.getUint8(offset);
    };

    ExifReader.prototype._getShortAt = function(offset) {
      return this._dataView.getUint16(offset, this._littleEndian);
    };

    ExifReader.prototype._getLongAt = function(offset) {
      return this._dataView.getUint32(offset, this._littleEndian);
    };

    ExifReader.prototype._getRationalAt = function(offset) {
      return this._getLongAt(offset) / this._getLongAt(offset + 4);
    };

    ExifReader.prototype._getUndefinedAt = function(offset) {
      return this._getByteAt(offset);
    };

    ExifReader.prototype._getSlongAt = function(offset) {
      return this._dataView.getInt32(offset, this._littleEndian);
    };

    ExifReader.prototype._getSrationalAt = function(offset) {
      return this._getSlongAt(offset) / this._getSlongAt(offset + 4);
    };

    ExifReader.prototype._splitNullSeparatedAsciiString = function(string) {
      var character, i, tagValue, _i, _len;

      tagValue = [];
      i = 0;
      for (_i = 0, _len = string.length; _i < _len; _i++) {
        character = string[_i];
        if (character === '\x00') {
          i++;
          continue;
        }
        if (tagValue[i] == null) {
          tagValue[i] = '';
        }
        tagValue[i] += character;
      }
      return tagValue;
    };

    ExifReader.prototype._readIptcTags = function() {
      var error, naaBlock;

      try {
        naaBlock = this._getIptcNaaResourceBlock();
      } catch (_error) {
        error = _error;
        return;
      }
      return this._parseIptcTags(naaBlock);
    };

    ExifReader.prototype._getIptcNaaResourceBlock = function() {
      var block, dataView, padding;

      dataView = this._dataView;
      while (true) {
        if (this._iptcDataOffset + 12 > dataView.byteLength) {
          break;
        }
        block = this._getIptcResourceBlock();
        if (block['type'] === 0x0404) {
          return block;
        } else {
          padding = 0;
          if (block['size'] % 2 !== 0) {
            padding = 1;
          }
          this._iptcDataOffset += 12 + block['size'] + padding;
        }
      }
      throw new Error('No IPTC NAA resource block.');
    };

    ExifReader.prototype._getIptcResourceBlock = function() {
      var dataView;

      dataView = this._dataView;
      if (dataView.getUint32(this._iptcDataOffset, false) !== this._BYTES_8BIM) {
        throw new Error('Not an IPTC resource block.');
      }
      return {
        'type': dataView.getUint16(this._iptcDataOffset + 4, false),
        'size': dataView.getUint16(this._iptcDataOffset + 10, false)
      };
    };

    ExifReader.prototype._parseIptcTags = function(naaBlock) {
      var endOfBlockOffset, tag, _results;

      this._iptcDataOffset += 12;
      endOfBlockOffset = this._iptcDataOffset + naaBlock['size'];
      _results = [];
      while (true) {
        if (this._iptcDataOffset >= endOfBlockOffset || this._iptcDataOffset >= this._dataView.byteLength) {
          break;
        }
        tag = this._readIptcTag();
        if ((this._tags[tag.name] == null) || (tag['repeatable'] == null)) {
          _results.push(this._tags[tag.name] = {
            'value': tag.value,
            'description': tag.description
          });
        } else {
          if (!(this._tags[tag.name] instanceof Array)) {
            this._tags[tag.name] = [
              {
                'value': this._tags[tag.name].value,
                'description': this._tags[tag.name].description
              }
            ];
          }
          _results.push(this._tags[tag.name].push({
            'value': tag.value,
            'description': tag.description
          }));
        }
      }
      return _results;
    };

    ExifReader.prototype._readIptcTag = function() {
      var dataView, tag, tagCode, tagDescription, tagName, tagSize, tagValue, _ref;

      dataView = this._dataView;
      if (dataView.getUint8(this._iptcDataOffset, false) !== 0x1c) {
        throw new Error('Not an IPTC NAA resource tag.');
      }
      tagCode = dataView.getUint16(this._iptcDataOffset + 1, false);
      tagSize = dataView.getUint16(this._iptcDataOffset + 3, false);
      tagValue = this._getIptcTagValue(this._iptcDataOffset + 5, tagSize);
      if (this._tagNames['iptc'][tagCode] != null) {
        if ((this._tagNames['iptc'][tagCode]['name'] != null) && (this._tagNames['iptc'][tagCode]['description'] != null)) {
          tagName = this._tagNames['iptc'][tagCode]['name'];
          tagDescription = this._tagNames['iptc'][tagCode]['description'](tagValue, this);
        } else {
          tagName = (_ref = this._tagNames['iptc'][tagCode]['name']) != null ? _ref : this._tagNames['iptc'][tagCode];
          if (tagValue instanceof Array) {
            tagDescription = tagValue.map(function(charCode) {
              return String.fromCharCode(charCode);
            }).join('');
          } else {
            tagDescription = tagValue;
          }
        }
        tag = {
          'name': tagName,
          'value': tagValue,
          'description': tagDescription
        };
        if (this._tagNames['iptc'][tagCode]['repeatable'] != null) {
          tag['repeatable'] = true;
        }
      } else {
        tag = {
          'name': "undefined-" + tagCode,
          'value': tagValue,
          'description': tagValue
        };
      }
      this._iptcDataOffset += 5 + tagSize;
      return tag;
    };

    ExifReader.prototype._getIptcTagValue = function(offset, size) {
      var dataView, value, valueIndex;

      dataView = this._dataView;
      value = (function() {
        var _i, _results;

        _results = [];
        for (valueIndex = _i = 0; 0 <= size ? _i < size : _i > size; valueIndex = 0 <= size ? ++_i : --_i) {
          _results.push(this._dataView.getUint8(offset + valueIndex));
        }
        return _results;
      }).call(this);
      return value;
    };

    ExifReader.prototype._getStringValue = function(value) {
      return String.fromCharCode.apply(null, value);
    };

    ExifReader.prototype._typeSizes = {
      1: 1,
      2: 1,
      3: 2,
      4: 4,
      5: 8,
      7: 1,
      9: 4,
      10: 8
    };

    ExifReader.prototype._tagTypes = {
      'BYTE': 1,
      'ASCII': 2,
      'SHORT': 3,
      'LONG': 4,
      'RATIONAL': 5,
      'UNDEFINED': 7,
      'SLONG': 9,
      'SRATIONAL': 10
    };

    ExifReader.prototype._tagNames = {
      '0th': {
        0x0100: 'ImageWidth',
        0x0101: 'ImageLength',
        0x0102: 'BitsPerSample',
        0x0103: 'Compression',
        0x0106: 'PhotometricInterpretation',
        0x010e: 'ImageDescription',
        0x010f: 'Make',
        0x0110: 'Model',
        0x0111: 'StripOffsets',
        0x0112: {
          'name': 'Orientation',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'top-left';
              case 2:
                return 'top-right';
              case 3:
                return 'bottom-right';
              case 4:
                return 'bottom-left';
              case 5:
                return 'left-top';
              case 6:
                return 'right-top';
              case 7:
                return 'right-bottom';
              case 8:
                return 'left-bottom';
              default:
                return 'Undefined';
            }
          }
        },
        0x0115: 'SamplesPerPixel',
        0x0116: 'RowsPerStrip',
        0x0117: 'StripByteCounts',
        0x011a: 'XResolution',
        0x011b: 'YResolution',
        0x011c: 'PlanarConfiguration',
        0x0128: {
          'name': 'ResolutionUnit',
          'description': function(value) {
            switch (value) {
              case 2:
                return 'inches';
              case 3:
                return 'centimeters';
              default:
                return 'Unknown';
            }
          }
        },
        0x012d: 'TransferFunction',
        0x0131: 'Software',
        0x0132: 'DateTime',
        0x013b: 'Artist',
        0x013e: 'WhitePoint',
        0x013f: 'PrimaryChromaticities',
        0x0201: 'JPEGInterchangeFormat',
        0x0202: 'JPEGInterchangeFormatLength',
        0x0211: 'YCbCrCoefficients',
        0x0212: 'YCbCrSubSampling',
        0x0213: {
          'name': 'YCbCrPositioning',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'centered';
              case 2:
                return 'co-sited';
              default:
                return 'undefied ' + value;
            }
          }
        },
        0x0214: 'ReferenceBlackWhite',
        0x8298: {
          'name': 'Copyright',
          'description': function(value) {
            return value.join('; ');
          }
        },
        0x8769: 'Exif IFD Pointer',
        0x8825: 'GPS Info IFD Pointer'
      },
      'exif': {
        0x829a: 'ExposureTime',
        0x829d: 'FNumber',
        0x8822: {
          'name': 'ExposureProgram',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Undefined';
              case 1:
                return 'Manual';
              case 2:
                return 'Normal program';
              case 3:
                return 'Aperture priority';
              case 4:
                return 'Shutter priority';
              case 5:
                return 'Creative program';
              case 6:
                return 'Action program';
              case 7:
                return 'Portrait mode';
              case 8:
                return 'Landscape mode';
              default:
                return 'Unknown';
            }
          }
        },
        0x8824: 'SpectralSensitivity',
        0x8827: 'ISOSpeedRatings',
        0x8828: {
          'name': 'OECF',
          'description': function(value) {
            return '[Raw OECF table data]';
          }
        },
        0x9000: {
          'name': 'ExifVersion',
          'description': function(value) {
            return ExifReader.prototype._getStringValue(value);
          }
        },
        0x9003: 'DateTimeOriginal',
        0x9004: 'DateTimeDigitized',
        0x9101: {
          'name': 'ComponentsConfiguration',
          'description': function(value) {
            var character, string, _i, _len;

            string = '';
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              character = value[_i];
              switch (character) {
                case 0x31:
                  string += 'Y';
                  break;
                case 0x32:
                  string += 'Cb';
                  break;
                case 0x33:
                  string += 'Cr';
                  break;
                case 0x34:
                  string += 'R';
                  break;
                case 0x35:
                  string += 'G';
                  break;
                case 0x36:
                  string += 'B';
              }
            }
            return string;
          }
        },
        0x9102: 'CompressedBitsPerPixel',
        0x9201: 'ShutterSpeedValue',
        0x9202: 'ApertureValue',
        0x9203: 'BrightnessValue',
        0x9204: 'ExposureBiasValue',
        0x9205: 'MaxApertureValue',
        0x9206: 'SubjectDistance',
        0x9207: {
          'name': 'MeteringMode',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'Average';
              case 2:
                return 'CenterWeightedAverage';
              case 3:
                return 'Spot';
              case 4:
                return 'MultiSpot';
              case 5:
                return 'Pattern';
              case 6:
                return 'Partial';
              case 255:
                return 'Other';
              default:
                return 'Unknown';
            }
          }
        },
        0x9208: {
          'name': 'LightSource',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'Daylight';
              case 2:
                return 'Fluorescent';
              case 3:
                return 'Tungsten (incandescent light)';
              case 4:
                return 'Flash';
              case 9:
                return 'Fine weather';
              case 10:
                return 'Cloudy weather';
              case 11:
                return 'Shade';
              case 12:
                return 'Daylight fluorescent (D 5700 – 7100K)';
              case 13:
                return 'Day white fluorescent (N 4600 – 5400K)';
              case 14:
                return 'Cool white fluorescent (W 3900 – 4500K)';
              case 15:
                return 'White fluorescent (WW 3200 – 3700K)';
              case 17:
                return 'Standard light A';
              case 18:
                return 'Standard light B';
              case 19:
                return 'Standard light C';
              case 20:
                return 'D55';
              case 21:
                return 'D65';
              case 22:
                return 'D75';
              case 23:
                return 'D50';
              case 24:
                return 'ISO studio tungsten';
              case 255:
                return 'Other light source';
              default:
                return 'Unknown';
            }
          }
        },
        0x9209: {
          'name': 'Flash',
          'description': function(value) {
            switch (value) {
              case 0x00:
                return 'Flash did not fire';
              case 0x01:
                return 'Flash fired';
              case 0x05:
                return 'Strobe return light not detected';
              case 0x07:
                return 'Strobe return light detected';
              case 0x09:
                return 'Flash fired, compulsory flash mode';
              case 0x0d:
                return 'Flash fired, compulsory flash mode, return light not detected';
              case 0x0f:
                return 'Flash fired, compulsory flash mode, return light detected';
              case 0x10:
                return 'Flash did not fire, compulsory flash mode';
              case 0x18:
                return 'Flash did not fire, auto mode';
              case 0x19:
                return 'Flash fired, auto mode';
              case 0x1d:
                return 'Flash fired, auto mode, return light not detected';
              case 0x1f:
                return 'Flash fired, auto mode, return light detected';
              case 0x20:
                return 'No flash function';
              case 0x41:
                return 'Flash fired, red-eye reduction mode';
              case 0x45:
                return 'Flash fired, red-eye reduction mode, return light not detected';
              case 0x47:
                return 'Flash fired, red-eye reduction mode, return light detected';
              case 0x49:
                return 'Flash fired, compulsory flash mode, red-eye reduction mode';
              case 0x4d:
                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected';
              case 0x4f:
                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected';
              case 0x59:
                return 'Flash fired, auto mode, red-eye reduction mode';
              case 0x5d:
                return 'Flash fired, auto mode, return light not detected, red-eye reduction mode';
              case 0x5f:
                return 'Flash fired, auto mode, return light detected, red-eye reduction mode';
              default:
                return 'Unknown';
            }
          }
        },
        0x920a: 'FocalLength',
        0x9214: {
          'name': 'SubjectArea',
          'description': function(value) {
            switch (value.length) {
              case 2:
                return "Location; X: " + value[0] + ", Y: " + value[1];
              case 3:
                return "Circle; X: " + value[0] + ", Y: " + value[1] + ", diameter: " + value[2];
              case 4:
                return "Rectangle; X: " + value[0] + ", Y: " + value[1] + ", width: " + value[2] + ", height: " + value[3];
              default:
                return 'Unknown';
            }
          }
        },
        0x927c: {
          'name': 'MakerNote',
          'description': function(value) {
            return '[Raw maker note data]';
          }
        },
        0x9286: {
          'name': 'UserComment',
          'description': function(value) {
            switch (value.slice(0, 8).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join('')) {
              case 'ASCII\x00\x00\x00':
                return value.slice(8, value.length).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join('');
              case 'JIS\x00\x00\x00\x00\x00':
                return '[JIS encoded text]';
              case 'UNICODE\x00':
                return '[Unicode encoded text]';
              case '\x00\x00\x00\x00\x00\x00\x00\x00':
                return '[Undefined encoding]';
            }
          }
        },
        0x9290: 'SubSecTime',
        0x9291: 'SubSecTimeOriginal',
        0x9292: 'SubSecTimeDigitized',
        0xa000: {
          'name': 'FlashpixVersion',
          'description': function(value) {
            var charCode, string, _i, _len;

            string = '';
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              charCode = value[_i];
              string += String.fromCharCode(charCode);
            }
            return string;
          }
        },
        0xa001: {
          'name': 'ColorSpace',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'sRGB';
              case 0xffff:
                return 'Uncalibrated';
              default:
                return 'Unknown';
            }
          }
        },
        0xa002: 'PixelXDimension',
        0xa003: 'PixelYDimension',
        0xa004: 'RelatedSoundFile',
        0xa005: 'Interoperability IFD Pointer',
        0xa20b: 'FlashEnergy',
        0xa20c: {
          'name': 'SpatialFrequencyResponse',
          'description': function(value) {
            return '[Raw SFR table data]';
          }
        },
        0xa20e: 'FocalPlaneXResolution',
        0xa20f: 'FocalPlaneYResolution',
        0xa210: {
          'name': 'FocalPlaneResolutionUnit',
          'description': function(value) {
            switch (value) {
              case 2:
                return 'inches';
              case 3:
                return 'centimeters';
              default:
                return 'Unknown';
            }
          }
        },
        0xa214: {
          'name': 'SubjectLocation',
          'description': function(value) {
            return "X: " + value[0] + ", Y: " + value[1];
          }
        },
        0xa215: 'ExposureIndex',
        0xa217: {
          'name': 'SensingMethod',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'Undefined';
              case 2:
                return 'One-chip color area sensor';
              case 3:
                return 'Two-chip color area sensor';
              case 4:
                return 'Three-chip color area sensor';
              case 5:
                return 'Color sequential area sensor';
              case 7:
                return 'Trilinear sensor';
              case 8:
                return 'Color sequential linear sensor';
              default:
                return 'Unknown';
            }
          }
        },
        0xa300: {
          'name': 'FileSource',
          'description': function(value) {
            switch (value) {
              case 3:
                return 'DSC';
              default:
                return 'Unknown';
            }
          }
        },
        0xa301: {
          'name': 'SceneType',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'A directly photographed image';
              default:
                return 'Unknown';
            }
          }
        },
        0xa302: {
          'name': 'CFAPattern',
          'description': function(value) {
            return '[Raw CFA pattern table data]';
          }
        },
        0xa401: {
          'name': 'CustomRendered',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Normal process';
              case 1:
                return 'Custom process';
              default:
                return 'Unknown';
            }
          }
        },
        0xa402: {
          'name': 'ExposureMode',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Auto exposure';
              case 1:
                return 'Manual exposure';
              case 2:
                return 'Auto bracket';
              default:
                return 'Unknown';
            }
          }
        },
        0xa403: {
          'name': 'WhiteBalance',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Auto white balance';
              case 1:
                return 'Manual white balance';
              default:
                return 'Unknown';
            }
          }
        },
        0xa404: {
          'name': 'DigitalZoomRatio',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Digital zoom was not used';
              default:
                return value;
            }
          }
        },
        0xa405: {
          'name': 'FocalLengthIn35mmFilm',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Unknown';
              default:
                return value;
            }
          }
        },
        0xa406: {
          'name': 'SceneCaptureType',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Standard';
              case 1:
                return 'Landscape';
              case 2:
                return 'Portrait';
              case 3:
                return 'Night scene';
              default:
                return 'Unknown';
            }
          }
        },
        0xa407: {
          'name': 'GainControl',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'None';
              case 1:
                return 'Low gain up';
              case 2:
                return 'High gain up';
              case 3:
                return 'Low gain down';
              case 4:
                return 'High gain down';
              default:
                return 'Unknown';
            }
          }
        },
        0xa408: {
          'name': 'Contrast',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Normal';
              case 1:
                return 'Soft';
              case 2:
                return 'Hard';
              default:
                return 'Unknown';
            }
          }
        },
        0xa409: {
          'name': 'Saturation',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Normal';
              case 1:
                return 'Low saturation';
              case 2:
                return 'High saturation';
              default:
                return 'Unknown';
            }
          }
        },
        0xa40a: {
          'name': 'Sharpness',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Normal';
              case 1:
                return 'Soft';
              case 2:
                return 'Hard';
              default:
                return 'Unknown';
            }
          }
        },
        0xa40b: {
          'name': 'DeviceSettingDescription',
          'description': function(value) {
            return '[Raw device settings table data]';
          }
        },
        0xa40c: {
          'name': 'SubjectDistanceRange',
          'description': function(value) {
            switch (value) {
              case 1:
                return 'Macro';
              case 2:
                return 'Close view';
              case 3:
                return 'Distant view';
              default:
                return 'Unknown';
            }
          }
        },
        0xa420: 'ImageUniqueID'
      },
      'gps': {
        0x0000: {
          'name': 'GPSVersionID',
          'description': function(value) {
            var _ref, _ref1;

            if ((value[0] === (_ref = value[1]) && _ref === 2) && (value[2] === (_ref1 = value[3]) && _ref1 === 0)) {
              return 'Version 2.2';
            } else {
              return 'Unknown';
            }
          }
        },
        0x0001: {
          'name': 'GPSLatitudeRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'N':
                return 'North latitude';
              case 'S':
                return 'South latitude';
              default:
                return 'Unknown';
            }
          }
        },
        0x0002: {
          'name': 'GPSLatitude',
          'description': function(value) {
            return value[0] + value[1] / 60 + value[2] / 3600;
          }
        },
        0x0003: {
          'name': 'GPSLongitudeRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'E':
                return 'East longitude';
              case 'W':
                return 'West longitude';
              default:
                return 'Unknown';
            }
          }
        },
        0x0004: {
          'name': 'GPSLongitude',
          'description': function(value) {
            return value[0] + value[1] / 60 + value[2] / 3600;
          }
        },
        0x0005: {
          'name': 'GPSAltitudeRef',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Sea level';
              case 1:
                return 'Sea level reference (negative value)';
              default:
                return 'Unknown';
            }
          }
        },
        0x0006: {
          'name': 'GPSAltitude',
          'description': function(value) {
            return value + ' m';
          }
        },
        0x0007: {
          'name': 'GPSTimeStamp',
          'description': function(value) {
            var padZero;

            padZero = function(num) {
              var i;

              return ((function() {
                var _i, _ref, _results;

                _results = [];
                for (i = _i = 0, _ref = 2 - ('' + Math.floor(num)).length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                  _results.push('0');
                }
                return _results;
              })()) + num;
            };
            return value.map(padZero).join(':');
          }
        },
        0x0008: 'GPSSatellites',
        0x0009: {
          'name': 'GPSStatus',
          'description': function(value) {
            switch (value.join('')) {
              case 'A':
                return 'Measurement in progress';
              case 'V':
                return 'Measurement Interoperability';
              default:
                return 'Unknown';
            }
          }
        },
        0x000a: {
          'name': 'GPSMeasureMode',
          'description': function(value) {
            switch (value.join('')) {
              case '2':
                return '2-dimensional measurement';
              case '3':
                return '3-dimensional measurement';
              default:
                return 'Unknown';
            }
          }
        },
        0x000b: 'GPSDOP',
        0x000c: {
          'name': 'GPSSpeedRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'K':
                return 'Kilometers per hour';
              case 'M':
                return 'Miles per hour';
              case 'N':
                return 'Knots';
              default:
                return 'Unknown';
            }
          }
        },
        0x000d: 'GPSSpeed',
        0x000e: {
          'name': 'GPSTrackRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'T':
                return 'True direction';
              case 'M':
                return 'Magnetic direction';
              default:
                return 'Unknown';
            }
          }
        },
        0x000f: 'GPSTrack',
        0x0010: {
          'name': 'GPSImgDirectionRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'T':
                return 'True direction';
              case 'M':
                return 'Magnetic direction';
              default:
                return 'Unknown';
            }
          }
        },
        0x0011: 'GPSImgDirection',
        0x0012: 'GPSMapDatum',
        0x0013: {
          'name': 'GPSDestLatitudeRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'N':
                return 'North latitude';
              case 'S':
                return 'South latitude';
              default:
                return 'Unknown';
            }
          }
        },
        0x0014: {
          'name': 'GPSDestLatitude',
          'description': function(value) {
            return value[0] + value[1] / 60 + value[2] / 3600;
          }
        },
        0x0015: {
          'name': 'GPSDestLongitudeRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'E':
                return 'East longitude';
              case 'W':
                return 'West longitude';
              default:
                return 'Unknown';
            }
          }
        },
        0x0016: {
          'name': 'GPSDestLongitude',
          'description': function(value) {
            return value[0] + value[1] / 60 + value[2] / 3600;
          }
        },
        0x0017: {
          'name': 'GPSDestBearingRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'T':
                return 'True direction';
              case 'M':
                return 'Magnetic direction';
              default:
                return 'Unknown';
            }
          }
        },
        0x0018: 'GPSDestBearing',
        0x0019: {
          'name': 'GPSDestDistanceRef',
          'description': function(value) {
            switch (value.join('')) {
              case 'K':
                return 'Kilometers';
              case 'M':
                return 'Miles';
              case 'N':
                return 'Knots';
              default:
                return 'Unknown';
            }
          }
        },
        0x001a: 'GPSDestDistance',
        0x001b: {
          'name': 'GPSProcessingMethod',
          'description': function(value) {
            switch (value.slice(0, 8).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join('')) {
              case 'ASCII\x00\x00\x00':
                return value.slice(8, value.length).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join('');
              case 'JIS\x00\x00\x00\x00\x00':
                return '[JIS encoded text]';
              case 'UNICODE\x00':
                return '[Unicode encoded text]';
              case '\x00\x00\x00\x00\x00\x00\x00\x00':
                return '[Undefined encoding]';
            }
          }
        },
        0x001c: {
          'name': 'GPSAreaInformation',
          'description': function(value) {
            switch (value.slice(0, 8).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join('')) {
              case 'ASCII\x00\x00\x00':
                return value.slice(8, value.length).map(function(charCode) {
                  return String.fromCharCode(charCode);
                }).join('');
              case 'JIS\x00\x00\x00\x00\x00':
                return '[JIS encoded text]';
              case 'UNICODE\x00':
                return '[Unicode encoded text]';
              case '\x00\x00\x00\x00\x00\x00\x00\x00':
                return '[Undefined encoding]';
            }
          }
        },
        0x001d: 'GPSDateStamp',
        0x001e: {
          'name': 'GPSDifferential',
          'description': function(value) {
            switch (value) {
              case 0:
                return 'Measurement without differential correction';
              case 1:
                return 'Differential correction applied';
              default:
                return 'Unknown';
            }
          }
        }
      },
      'interoperability': {
        0x0001: 'InteroperabilityIndex',
        0x0002: 'UnknownInteroperabilityTag0x0002',
        0x1001: 'UnknownInteroperabilityTag0x1001',
        0x1002: 'UnknownInteroperabilityTag0x1002'
      },
      'iptc': {
        0x015a: {
          'name': 'Coded Character Set',
          'description': function(value) {
            switch (ExifReader.prototype._getStringValue(value)) {
              case '\x1b%G':
                return 'UTF-8';
              case '\x1b%/G':
                return 'UTF-8 Level 1';
              case '\x1b%/H':
                return 'UTF-8 Level 2';
              case '\x1b%/I':
                return 'UTF-8 Level 3';
              default:
                return 'Unknown';
            }
          }
        },
        0x0200: {
          'name': 'Record Version',
          'description': function(value) {
            return ((value[0] << 8) + value[1]).toString();
          }
        },
        0x0203: 'Object Type Reference',
        0x0204: 'Object Attribute Reference',
        0x0205: 'Object Name',
        0x0207: 'Edit Status',
        0x0208: {
          'name': 'Editorial Update',
          'description': function(value) {
            switch (ExifReader.prototype._getStringValue(value)) {
              case '01':
                return 'Additional Language';
              default:
                return 'Unknown';
            }
          }
        },
        0x020a: 'Urgency',
        0x020c: {
          'name': 'Subject Reference',
          'repeatable': true,
          'description': function(value) {
            var parts;

            parts = ExifReader.prototype._getStringValue(value).split(':');
            return parts[2] + (parts[3] ? '/' + parts[3] : '') + (parts[4] ? '/' + parts[4] : '');
          }
        },
        0x020f: 'Category',
        0x0214: {
          'name': 'Supplemental Category',
          'repeatable': true
        },
        0x0216: 'Fixture Identifier',
        0x0219: {
          'name': 'Keywords',
          'repeatable': true
        },
        0x021a: {
          'name': 'Content Location Code',
          'repeatable': true
        },
        0x021b: {
          'name': 'Content Location Name',
          'repeatable': true
        },
        0x021e: 'Release Date',
        0x0223: 'Release Time',
        0x0225: 'Expiration Date',
        0x0226: 'Expiration Time',
        0x0228: 'Special Instructions',
        0x022a: {
          'name': 'Action Advised',
          'description': function(value) {
            switch (ExifReader.prototype._getStringValue(value)) {
              case '01':
                return 'Object Kill';
              case '02':
                return 'Object Replace';
              case '03':
                return 'Object Append';
              case '04':
                return 'Object Reference';
              default:
                return 'Unknown';
            }
          }
        },
        0x022d: {
          'name': 'Reference Service',
          'repeatable': true
        },
        0x022f: {
          'name': 'Reference Date',
          'repeatable': true
        },
        0x0232: {
          'name': 'Reference Number',
          'repeatable': true
        },
        0x0237: {
          'name': 'Date Created',
          'description': function(value) {
            var date;

            date = ExifReader.prototype._getStringValue(value);
            if (date.length >= 8) {
              return date.substr(0, 4) + '-' + date.substr(4, 2) + '-' + date.substr(6, 2);
            } else {
              return date;
            }
          }
        },
        0x023c: {
          'name': 'Time Created',
          'description': function(value) {
            var parsedTime, time;

            parsedTime = time = ExifReader.prototype._getStringValue(value);
            if (time.length >= 6) {
              parsedTime = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(4, 2);
              if (time.length === 11) {
                parsedTime += time.substr(6, 1) + time.substr(7, 2) + ':' + time.substr(9, 2);
              }
            }
            return parsedTime;
          }
        },
        0x023e: {
          'name': 'Digital Creation Date',
          'description': function(value) {
            var date;

            date = ExifReader.prototype._getStringValue(value);
            if (date.length >= 8) {
              return date.substr(0, 4) + '-' + date.substr(4, 2) + '-' + date.substr(6, 2);
            } else {
              return date;
            }
          }
        },
        0x023f: {
          'name': 'Digital Creation Time',
          'description': function(value) {
            var parsedTime, time;

            parsedTime = time = ExifReader.prototype._getStringValue(value);
            if (time.length >= 6) {
              parsedTime = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(4, 2);
              if (time.length === 11) {
                parsedTime += time.substr(6, 1) + time.substr(7, 2) + ':' + time.substr(9, 2);
              }
            }
            return parsedTime;
          }
        },
        0x0241: 'Originating Program',
        0x0246: 'Program Version',
        0x024b: {
          'name': 'Object Cycle',
          'description': function(value) {
            switch (ExifReader.prototype._getStringValue(value)) {
              case 'a':
                return 'morning';
              case 'p':
                return 'evening';
              case 'b':
                return 'both';
              default:
                return 'Unknown';
            }
          }
        },
        0x0250: {
          'name': 'By-line',
          'repeatable': true
        },
        0x0255: {
          'name': 'By-line Title',
          'repeatable': true
        },
        0x025a: 'City',
        0x025c: 'Sub-location',
        0x025f: 'Province/State',
        0x0264: 'Country/Primary Location Code',
        0x0265: 'Country/Primary Location Name',
        0x0267: 'Original Transmission Reference',
        0x0269: 'Headline',
        0x026e: 'Credit',
        0x0273: 'Source',
        0x0274: 'Copyright Notice',
        0x0276: {
          'name': 'Contact',
          'repeatable': true
        },
        0x0278: 'Caption/Abstract',
        0x027a: {
          'name': 'Writer/Editor',
          'repeatable': true
        },
        0x027d: {
          'name': 'Rasterized Caption',
          'description': function(value) {
            return value;
          }
        },
        0x0282: 'Image Type',
        0x0283: {
          'name': 'Image Orientation',
          'description': function(value) {
            switch (ExifReader.prototype._getStringValue(value)) {
              case 'P':
                return 'Portrait';
              case 'L':
                return 'Landscape';
              case 'S':
                return 'Square';
              default:
                return 'Unknown';
            }
          }
        },
        0x0287: 'Language Identifier',
        0x0296: {
          'name': 'Audio Type',
          'description': function(value) {
            var description, stringValue;

            stringValue = ExifReader.prototype._getStringValue(value);
            description = '';
            switch (stringValue.charAt(0)) {
              case '1':
                description += 'Mono';
                break;
              case '2':
                description += 'Stereo';
            }
            switch (stringValue.charAt(1)) {
              case 'A':
                description += ', actuality';
                break;
              case 'C':
                description += ', question and answer session';
                break;
              case 'M':
                description += ', music, transmitted by itself';
                break;
              case 'Q':
                description += ', response to a question';
                break;
              case 'R':
                description += ', raw sound';
                break;
              case 'S':
                description += ', scener';
                break;
              case 'V':
                description += ', voicer';
                break;
              case 'W':
                description += ', wrap';
            }
            if (description !== '') {
              return description;
            } else {
              return stringValue;
            }
          }
        },
        0x0297: {
          'name': 'Audio Sampling Rate',
          'description': function(value) {
            return parseInt(ExifReader.prototype._getStringValue(value, 10)) + ' Hz';
          }
        },
        0x0298: {
          'name': 'Audio Sampling Resolution',
          'description': function(value) {
            var bits;

            bits = parseInt(ExifReader.prototype._getStringValue(value, 10));
            return bits + (bits === 1 ? ' bit' : ' bits');
          }
        },
        0x0299: {
          'name': 'Audio Duration',
          'description': function(value) {
            var duration;

            duration = ExifReader.prototype._getStringValue(value);
            if (duration.length >= 6) {
              return duration.substr(0, 2) + ':' + duration.substr(2, 2) + ':' + duration.substr(4, 2);
            } else {
              return duration;
            }
          }
        },
        0x029a: 'Audio Outcue',
        0x02c8: {
          'name': 'ObjectData Preview File Format',
          'description': function(value) {
            var stringValue;

            stringValue = ExifReader.prototype._getStringValue(value);
            switch (stringValue) {
              case '00':
                return 'No ObjectData';
              case '01':
                return 'IPTC-NAA Digital Newsphoto Parameter Record';
              case '02':
                return 'IPTC7901 Recommended Message Format';
              case '03':
                return 'Tagged Image File Format (Adobe/Aldus Image data)';
              case '04':
                return 'Illustrator (Adobe Graphics data)';
              case '05':
                return 'AppleSingle (Apple Computer Inc)';
              case '06':
                return 'NAA 89-3 (ANPA 1312)';
              case '07':
                return 'MacBinary II';
              case '08':
                return 'IPTC Unstructured Character Oriented File Format (UCOFF)';
              case '09':
                return 'United Press International ANPA 1312 variant';
              case '10':
                return 'United Press International Down-Load Message';
              case '11':
                return 'JPEG File Interchange (JFIF)';
              case '12':
                return 'Photo-CD Image-Pac (Eastman Kodak)';
              case '13':
                return 'Microsoft Bit Mapped Graphics File [*.BMP]';
              case '14':
                return 'Digital Audio File [*.WAV] (Microsoft & Creative Labs)';
              case '15':
                return 'Audio plus Moving Video [*.AVI] (Microsoft)';
              case '16':
                return 'PC DOS/Windows Executable Files [*.COM][*.EXE]';
              case '17':
                return 'Compressed Binary File [*.ZIP] (PKWare Inc)';
              case '18':
                return 'Audio Interchange File Format AIFF (Apple Computer Inc)';
              case '19':
                return 'RIFF Wave (Microsoft Corporation)';
              case '20':
                return 'Freehand (Macromedia/Aldus)';
              case '21':
                return 'Hypertext Markup Language "HTML" (The Internet Society)';
              case '22':
                return 'MPEG 2 Audio Layer 2 (Musicom), ISO/IEC';
              case '23':
                return 'MPEG 2 Audio Layer 3, ISO/IEC';
              case '24':
                return 'Portable Document File (*.PDF) Adobe';
              case '25':
                return 'News Industry Text Format (NITF)';
              case '26':
                return 'Tape Archive (*.TAR)';
              case '27':
                return 'Tidningarnas Telegrambyrå NITF version (TTNITF DTD)';
              case '28':
                return 'Ritzaus Bureau NITF version (RBNITF DTD)';
              case '29':
                return 'Corel Draw [*.CDR]';
              default:
                return 'Unknown format ' + stringValue;
            }
          }
        },
        0x02c9: {
          'name': 'ObjectData Preview File Format Version',
          'description': function(value, exif) {
            var formatVersions, stringValue, _ref;

            formatVersions = {
              '00': {
                '00': '1'
              },
              '01': {
                '01': '1',
                '02': '2',
                '03': '3',
                '04': '4'
              },
              '02': {
                '04': '4'
              },
              '03': {
                '01': '5.0',
                '02': '6.0'
              },
              '04': {
                '01': '1.40'
              },
              '05': {
                '01': '2'
              },
              '06': {
                '01': '1'
              },
              '11': {
                '01': '1.02'
              },
              '20': {
                '01': '3.1',
                '02': '4.0',
                '03': '5.0',
                '04': '5.5'
              },
              '21': {
                '02': '2.0'
              }
            };
            stringValue = ExifReader.prototype._getStringValue(value);
            if ((exif._tags['ObjectData Preview File Format'] != null) && (((_ref = formatVersions[ExifReader.prototype._getStringValue(exif._tags['ObjectData Preview File Format'].value)]) != null ? _ref[stringValue] : void 0) != null)) {
              return formatVersions[ExifReader.prototype._getStringValue(exif._tags['ObjectData Preview File Format'].value)][stringValue];
            }
            return stringValue;
          }
        },
        0x02ca: 'ObjectData Preview Data'
      }
    };

    /*
    # Gets the image's value of the tag with the given name.
    #
    # name string The name of the tag to get the value of
    #
    # Returns the value of the tag with the given name if it exists,
    # otherwise throws "Undefined".
    */


    ExifReader.prototype.getTagValue = function(name) {
      if (this._tags[name] != null) {
        return this._tags[name].value;
      } else {
        return void 0;
      }
    };

    /*
    # Gets the image's description of the tag with the given name.
    #
    # name string The name of the tag to get the description of
    #
    # Returns the description of the tag with the given name if it exists,
    # otherwise throws "Undefined".
    */


    ExifReader.prototype.getTagDescription = function(name) {
      if (this._tags[name] != null) {
        return this._tags[name].description;
      } else {
        return void 0;
      }
    };

    /*
    # Gets all the image's tags.
    #
    # Returns the image's tags as an associative array: name -> description.
    */


    ExifReader.prototype.getAllTags = function() {
      return this._tags;
    };

    return ExifReader;

  }).call(this);

}).call(this);
